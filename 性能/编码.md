<!--
 * @Author: your name
 * @Date: 2021-06-11 15:49:26
 * @LastEditTime: 2021-06-11 16:00:52
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings E
 * @FilePath: /methodsAccumulation/性能/编码.md
-->
1. 避免全局查找
使用全局变量和函数要比局部的开销更大，可以将全局变量保存在局部的变量中，再去调用.
```js
    // 全局查找 document
    function updateElement() {
        var p = document.getElementsByTagName('p');
        var title = document.getElementById('title');
        
        p.forEach(val => {
            val.innerHTML = document.title;
        })
        title.innerHTML = 'world';
    }
    
    // 局部查找
    function updateElement() {
        var doc = document;
        var p = doc.getElementsByTagName('p');
        var title = doc.getElementById('title');
        p.forEach(val => {
            val.innerHTML = doc.title;
        })
        title.innerHTML = 'world';
    } 
```
2. 避免with语句
with语句相信大家都听说过。它会创建自己的作用域，因此会增加其中执行代码的作用域链长度，造成with语句中执行的代码会比外面执行的代码要慢。
3. 避免不必要的属性查找
能减少算法的复杂度要尽量减少，尽可能地多使用局部变量将属性查找替换为值查找。
```js
// bad
    var obj = { a: 1, b: 100 };
    var result = obj.b - obj.a;
    console.log(result);
// 上面代码访问变量的时间复杂度为O(n)，对象在查找时必须向原型链中搜索该属性，所以对象属性越多，查找时间越长
```
4. 简化循环终止条件
```js
    // before
    const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
    for (let i = 0; i < arr.length; i ++) {
        ...
    }

    // after
    const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
    for (let i = 0, len = arr.length; i < len; i ++) {
        ...
    }
```
5. 多个变量声明,使用数组和对象字面量
代码语句数量也是会影响执行的操作的速度，完成多个操作的单个语句要比完成单个操作的多个语句快
```js
    // before
    var a = 1;
    var b = 'a';
    var c = {};
    var d = [];
    var arr = [];
  arr[0] = 'aaa';
  arr[1] = 'bbb';
  arr[2] = 'ccc';
    // after
    var a = 1,
        b = 'a',
        c = {},
        d = [];
        var arr = ['aaa', 'bbb', 'ccc'];
```
6. 优化DOM交互
1）createDocumentFragment，创建文档片段对象，只有一次插入节点的操作，有效减少节点更新造成的性能消耗；使用innerHTML也可以造成差不多的效果，但是字符串拼接会有一定的性能损失。
```js
    var list = document.getElementById('list');
    var fragment = document.createDocumentFragment();
    
    for (let x = 0, max = 10, x < max; x++) {
        var li = document.createElement('li');
        li.innerHTML = x;
        fragment.appendChild(li);
    }
    list.appendChild(fragment);
```
2）使用事件委托，利用事件冒泡，避免单个监听增加导致性能变差（）
[事件冒泡、事件捕获和事件委托]https://www.cnblogs.com/Chen-XiaoJun/p/6210987.html