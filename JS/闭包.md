<!--
 * @Author: your name
 * @Date: 2021-06-10 15:22:08
 * @LastEditTime: 2021-06-10 20:16:17
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /methodsAccumulation/JS/闭包.md
-->
https://juejin.cn/post/6971338414704558093
# 变量提升
所谓 “变量提升” 是代码函数、变量的声明会被移动到代码的最最最最前面，在编译阶段 Javascript引擎将其存入内存中。没错，一段 js 代码在执行之前是被引擎编译，先编译阶段完成后，再进入执行阶段。
1. 编译阶段，编译阶段遇到相同的变量会直接覆盖，环境变量只存一个同名函数；
2. 执行阶段，从变量环境查找调用

# 执行上下文
1. 执行上下文是Javascript执行一段代码时的运行环境
2. 所有的 JS 代码在运行时都是在执行上下文中进行的。执行上下文是一个抽象的概念，JS 中有三种执行上下文：
1)全局执行上下文，默认的，在浏览器中是 window 对象，并且 this 在非严格模式下指向它
2)函数执行上下文，JS 的函数每当被调用时会创建一个上下文
3)Eval 执行上下文，eval 函数会产生自己的上下文，这里不讨论

# 执行栈
https://www.cnblogs.com/zhazhanitian/p/13064274.html
通常，我们的代码中都不止一个上下文，那这些上下文的执行顺序应该是怎样的？从上往下依次执行？

栈，是一种数据结构，具有先进后出的原则。JS 中的执行栈就具有这样的结构，当引擎第一次遇到 JS 代码时，会产生一个全局执行上下文并压入执行栈，每遇到一个函数调用，就会往栈中压入一个新的上下文。引擎执行栈顶的函数，执行完毕，弹出当前执行上下文
```js
function foo() {
  console.log('1')
  bar();
  console.log('3')
}
 
function bar() {
  console.log('2')
}
foo()
```
以引例来说明。当 foo() 函数被调用，将 foo 函数的执行上下文压入执行栈，接着执行输出 ‘1’；当 bar() 函数被调用，将 bar 函数的执行上下文压入执行栈，接着执行输出 ‘2’；bar() 执行完毕，被弹出执行栈，foo() 函数接着执行，输出 ‘3’；foo() 函数执行完毕，被弹出执行栈;
## 【总结】
1. 可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则
2. JavaScript执行在单线程上，所有的代码都是排队执行。
3. 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。
4. 每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。
5. 浏览器的 JS 执行引擎总是访问栈顶的执行上下文。
6.全局上下文只有唯一的一个，它在浏览器关闭时出栈。
# 调用栈
https://www.cnblogs.com/zhazhanitian/p/13064274.html
调用堆栈顾名思义是一个具有LIFO(后进先出)结构的【堆栈】，用于存储在代码执行期间创建的所有执行上下文
JS 只有一个调用栈，因为它是一种单线程编程语言，调用堆栈具有 LIFO 结构，这意味着项目只能从堆栈顶部添加或删除
```js
const second = () => {
  console.log('Hello there!')
}
const first = () => {
  console.log('Hi there!')
  second();
  console.log('The End')
}
first()
```
步骤如下：
1. 当执行此代码时，将创建一个全局执行上下文(由main()表示)并将其推到调用堆栈的顶部。当遇到对first()的调用时，它会被推送到堆栈的顶部;
2. 接下来,console.log('Hi there!')被推送到堆栈的顶部，当它完成时，它会从堆栈中弹出。之后，我们调用second()，因此second()函数被推到堆栈的顶部
3. console.log('Hello there!')被推送到堆栈顶部，并在完成时弹出堆栈。second() 函数结束，因此它从堆栈中弹出
4. console.log(“the End”)被推到堆栈的顶部，并在完成时删除。之后，first()函数完成，因此从堆栈中删除它
5. 程序在这一点上完成了它的执行，所以全局执行上下文(main())从堆栈中弹出
可以看出其实执行栈和调用堆栈是可以相互嵌套的

# 事件轮询
事件轮询的工作是监听调用堆栈，并确定调用堆栈是否为空。如果调用堆栈是空的，它将检查消息队列，看看是否有任何挂起的回调等待执行
在这种情况下，消息队列包含一个回调，此时调用堆栈为空。因此，事件轮询将回调推到堆栈的顶部。
总结：事件轮询检查调用堆栈是否为空，并在调用堆栈为空并执行回调时将事件回调推送到堆栈；