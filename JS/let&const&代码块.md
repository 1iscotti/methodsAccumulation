<!--
 * @Author: your name
 * @Date: 2021-06-11 18:13:42
 * @LastEditTime: 2021-07-06 20:03:34
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /methodsAccumulation/JS/let/const.md
-->
# let
1. let深入理解---let存在变量提升吗
https://www.jianshu.com/p/0f49c88cf169 ？
https://zhuanlan.zhihu.com/p/28140450 ？
```js
let a = 1
{
  a = 2  // ReferenceError: a is not defined
  // 疑问1：并没有将外部a变为1,是否说明let仍旧存在变量提升，只是到变量初始化过程中存在临时死区？（疑问1不可取）
  // 疑问2:let 不提升，并且不允许变量临时更改绑定，所以在 let 所在块级不允许使用外面的a? javascript不支持，也不准备支持变量临时改指向,所以产生临时死区。
  // 暂且偏向疑问2吧....
  // 解释：https://262.ecma-international.org/6.0/#sec-let-and-const-declarations
  块级作用域
  // ES6规定，let/const 命令会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。
  // 总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。
  // 从程序执行进入代码块（或函数）的那一刻起，变量就开始进入“未初始化”状态。它一直保持未初始化状态，直至程序执行到相应的 let 语句。换句话说，一个变量从技术的角度来讲是存在的，但是在 let 之前还不能使用。（https://zh.javascript.info/closure说法）
  // 这在语法上，称为 “暂时性死区”（ temporal dead zone，简称 TDZ）
  // hoisting：不管你把 var a 写在函数的哪一行，都好像写在第一行一样；当前函数作用域里的所有 a 都表示你写的这个 a，这就是 hoisting
  let a  
}
```
2. 如何理解 let x = x 报错之后，再次 let x 依然会报错
这个问题说明：如果 let x 的初始化过程失败了，那么x 变量就将永远处于 created 状态。
你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）。
由于 x 无法被初始化，所以 x 永远处在暂时死区（也就是盗梦空间里的 limbo）！
有人会觉得 JS 坑，怎么能出现这种情况；其实问题不大，因为此时代码已经报错了，后面的代码想执行也没机会。

3. 词法环境
[解释了1中的现象]当脚本开始运行，词法环境预先填充了所有声明的变量。
最初，它们处于“未初始化（Uninitialized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 let 声明前，不能引用它。几乎就像变量不存在一样。（对应1）
[注意]
函数声明： 不同之处在于函数声明的初始化会被立即完成。当创建了一个词法环境（Lexical Environment）时，函数声明会立即变为即用型函数（不像 let 那样直到声明处才可用）。

1)变量是特殊内部对象的属性，与当前正在执行的（代码）块/函数/脚本有关。
2)操作变量实际上是操作该对象的属性。
总结： “词法环境”是一个规范对象（specification object）：它仅仅是存在于 编程语言规范 中的“理论上”存在的，用于描述事物如何运作的对象。我们无法在代码中获取该对象并直接对其进行操作。但 JavaScript 引擎同样可以优化它，比如清除未被使用的变量以节省内存和执行其他内部技巧等，但显性行为应该是和上述的无差。


# {} 代码块
代码块的作用
 *     在JS中可以使用{}来为语句进行分组,
 *         同一个{}中的语句我们称为是一组语句，
 *         它们要么都执行，要么都不执行，
 *         一个{}中的语句我们也称为叫一个代码块
 *         在代码块的后边就不用再编写;了
1. 只具有分组的的作用，没有其他的用途?
2. 代码块内容的内容，在外部是完全可见的

# var
1. var 声明的变量没有块级作用域也没有循环局部作用域：var 声明的变量没有块级作用域，它们仅在当前函数内可见，或者全局可见（如果变量是在函数外声明的）
```js
for (var i = 0; i < 10; i++) {
  var one = 1;
  // ...
}
alert(i);   // 10，"i" 在循环结束后仍可见，它是一个全局变量
alert(one); // 1，"one" 在循环结束后仍可见，它是一个全局变量

```
2. var，我们可以重复声明一个变量，不管多少次都行(以最新赋值为准)
3. 声明会被提升，但是赋值不会，var 变量声明在函数开头就会被处理（脚本启动对应全局变量）
```js
function sayHi() {
  alert(phrase); // undefined
  var phrase = "Hello";
}
sayHi();
```
4. IIFE
模仿块级作用域的方法-立即调用函数表达式
```js
// 除了括号还有！、+等
// 需要使用圆括号把该函数表达式包起来，以告诉 JavaScript，这个函数是在另一个表达式的上下文中创建的，因此它是一个函数表达式：它不需要函数名，可以立即调用
(function() {

  var message = "Hello";

  alert(message); // Hello

})();
```
5. 在浏览器中，使用 var（而不是 let/const！）声明的全局函数和变量会成为全局对象的属性。