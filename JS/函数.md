<!--
 * @Author: your name
 * @Date: 2021-06-23 20:57:38
 * @LastEditTime: 2021-07-06 21:10:52
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /methodsAccumulation/JS/函数.md
-->
# 函数表达式&函数申明
## 区别
[1.1] 首先是语法：如何通过代码对它们进行区分。
<b>函数声明：在主代码流中声明为单独的语句的函数。</b>
// 函数声明
function sum(a, b) {
  return a + b;
}
<b>函数表达式：在一个表达式中或另一个语法结构中创建的函数。下面这个函数是在赋值表达式 = 右侧创建的：</b>
// 函数表达式
let sum = function(a, b) {
  return a + b;
};

[1.2]
[注意]更细微的差别是，JavaScript 引擎会在 什么时候 创建函数。
函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。
一旦代码执行到赋值表达式 let sum = function… 的右侧，此时就会开始创建该函数，并且可以从现在开始使用（分配，调用等）。
函数声明则不同。
在函数声明被定义之前，它就可以被调用。
例如，一个全局函数声明对整个脚本来说都是可见的，无论它被写在这个脚本的哪个位置。
这是内部算法的原故。当 JavaScript 准备 运行脚本时，首先会在脚本中寻找全局函数声明，并创建这些函数。我们可以将其视为“初始化阶段”。
在处理完所有函数声明后，代码才被执行。所以运行时能够使用这些函数。

[1.3]
函数表达式在代码执行到它时才会被创建。只会发生在 (*) 行。为时已晚。
函数声明的另外一个特殊的功能是它们的块级作用域。
[注意]严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。

## 总结
函数是值。它们可以在代码的任何地方被分配，复制或声明。
如果函数在主代码流中被声明为单独的语句，则称为“函数声明”。
如果该函数是作为表达式的一部分创建的，则称其“函数表达式”。
在执行代码块之前，内部算法会先处理函数声明。所以函数声明在其被声明的代码块内的任何位置都是可见的。
函数表达式在执行流程到达时创建。

# 箭头函数
## 箭头函数没有自身的 this。现在我们知道了它们也没有特殊的 arguments 对象。
```js
function f() {
  let showArg = () => alert(arguments[0]);
  showArg();
}
f(1); // 1,访问到的 arguments 并不属于箭头函数，而是属于箭头函数外部的“普通”函数。
```
# 词法环境
https://zh.javascript.info/closure
1. 函数将从内到外依次在对应的词法环境中寻找目标变量，它使用最新的值。
```js
let name = "John";
function sayHi() {
  alert("Hi, " + name);
}
name = "Pete";
sayHi(); // Pete
```
2. 函数调用完成后，会将词法环境和其中的所有变量从内存中删除。因为现在没有任何对它们的引用了。与 JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。
但是，如果有一个嵌套的函数在函数结束后仍可达，则它将具有引用词法环境的 [[Environment]] 属性

3. 内部和外部的词法环境
(1)在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。
(2)所有函数在创建时都会有一个指针指向创建它的外部环境：[[Environment]]
```js
// 函数 counter 和 counter2 是通过 makeCounter 的不同调用创建的。因此，它们具有独立的外部词法环境，每一个都有自己的 count(上诉2)
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter(); // 在每次 makeCounter() 调用的开始，都会创建一个新的词法环境对象，以存储该 makeCounter 运行时的变量(上述1)
let counter2 = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1

alert( counter2() ); // 0
alert( counter2() ); // 1
---------------------------
// up和down函数都是在同一个词法环境中创建的，所以它们可以共享对同一个 count 变量的访问
function Counter() {
  let count = 0;

  this.up = function() {
    return ++count;
  };

  this.down = function() {
    return --count;
  };
}

let counter = new Counter();
----------
// 闭包&柯理化
function sum(a) {
  return function(b) {
    return a+b;
  }
}
function inBetween(a, b) {
  return function(x) {
    return x >= a && x <= b;
  };
}
arr.filter(inBetween(3, 6))
-----------
function makeArmy() {
  let shooters = [];

  let i = 0;
  while (i < 10) {
    let j = i; // 声明了一个“局部迭代”变量 j，并将 i 复制到其中。原始类型是“按值”复制的，因此实际上我们得到的是属于当前循环迭代的独立的 i 的副本。
    let shooter = function() { // 创建一个 shooter 函数，
      console.log('i: ', j);// 应该显示其编号
    };
    shooters.push(shooter); // 将此 shooter 函数添加到数组中
    i++;
  }
  // 因为 for 循环在每次迭代中，都会生成一个带有自己的变量 i 的新词法环境。因此，在每次迭代中生成的 shooter 函数引用的都是自己的 i
  // for 构造在这里很特殊：在其中声明的变量被视为块的一部分
  // for (let i = 0; i < 10; i++) {
  //   let shooter = function() { // 创建一个 shooter 函数，
  //     console.log('i: ', i);// 应该显示其编号
  //   };
  //   shooters.push(shooter); // 将此 shooter 函数添加到数组中
  // }

  // ……返回 shooters 数组
  return shooters;
}
// 为了让她们输入理想中的值，即创建内部词法环境中的i，避免统一获取外部词法环境中的i=10
let army = makeArmy();
army[0](); // 编号为 0 的 shooter 显示的是0
army[1](); // 编号为 1 的 shooter 显示的是 1
army[2](); // 2。
```

# 自定义属性
1. 函数属性有时会用来替代闭包，count 的值是绑定到函数的，那么就很容易修改；
```js
function makeCounter() {
  // 不需要这个了
  // let count = 0
  function counter() {
    return counter.count++;
  };
  // 属性替代闭包
  counter.count = 0;

  return counter;
}

let counter = makeCounter();
let counter1 = makeCounter();
console.log( 'counter',counter() ); // 0
console.log( 'counter',counter() ); // 1
console.log( 'counter1',counter1() ); // 0
console.log( 'counter1',counter1() ); // 1
counter.count = 10;
console.log( 'counter10',counter() ); // 10
```
2. 命名函数表达式
内部名'func'存在的意义：func 是函数局部域的,“内部名”特性只针对函数表达式，而不是函数声明。对于函数声明，没有用来添加“内部”名的语法.
1)它允许函数在内部引用自己。
2)它在函数外是不可见的。
```js
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // 使用 func 再次调用函数自身
  }
};

sayHi(); // Hello, Guest
// 但这不工作：
func(); // Error, func is not defined（在函数外不可见）
```